package scalikejdbc.athena

import java.sql.{Array => SQLArray, _}
import java.util.{Properties, Map => JMap}
import java.util.concurrent.Executor

private[athena] class AthenaConnection(underlying: Connection) extends Connection {

  override def prepareStatement(sql: String): PreparedStatement =
    new AthenaPreparedStatement(this, createStatement(), sql)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement =
    new AthenaPreparedStatement(this, createStatement(resultSetType, resultSetConcurrency), sql)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement =
    new AthenaPreparedStatement(this, createStatement(resultSetType, resultSetConcurrency, resultSetHoldability), sql)

  override def commit(): Unit =
    underlying.commit()

  override def getHoldability: Int =
    underlying.getHoldability

  override def setCatalog(catalog: String): Unit =
    underlying.setCatalog(catalog)

  override def setHoldability(holdability: Int): Unit =
    underlying.setHoldability(holdability)

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement =
    underlying.prepareStatement(sql, autoGeneratedKeys)

  override def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement =
    underlying.prepareStatement(sql, columnIndexes)

  override def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement =
    underlying.prepareStatement(sql, columnNames)

  override def createClob(): Clob =
    underlying.createClob()

  override def setSchema(schema: String): Unit =
    underlying.setSchema(schema)

  override def setClientInfo(name: String, value: String): Unit =
    underlying.setClientInfo(name, value)

  override def setClientInfo(properties: Properties): Unit =
    underlying.setClientInfo(properties)

  override def createSQLXML(): SQLXML =
    underlying.createSQLXML()

  override def getCatalog: String =
    underlying.getCatalog

  override def createBlob(): Blob =
    underlying.createBlob()

  override def createStatement(): Statement =
    underlying.createStatement()

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement =
    underlying.createStatement(resultSetType, resultSetConcurrency)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement =
    underlying.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

  override def abort(executor: Executor): Unit =
    underlying.abort(executor)

  override def setAutoCommit(autoCommit: Boolean): Unit =
    underlying.setAutoCommit(autoCommit)

  override def getMetaData: DatabaseMetaData =
    underlying.getMetaData

  override def setReadOnly(readOnly: Boolean): Unit =
    underlying.setReadOnly(readOnly)

  override def prepareCall(sql: String): CallableStatement =
    underlying.prepareCall(sql)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement =
    underlying.prepareCall(sql, resultSetType, resultSetConcurrency)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement =
    underlying.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  override def setTransactionIsolation(level: Int): Unit =
    underlying.setTransactionIsolation(level)

  override def getWarnings: SQLWarning =
    underlying.getWarnings

  override def releaseSavepoint(savepoint: Savepoint): Unit =
    underlying.releaseSavepoint(savepoint)

  override def nativeSQL(sql: String): String =
    underlying.nativeSQL(sql)

  override def isReadOnly: Boolean =
    underlying.isReadOnly

  override def createArrayOf(typeName: String, elements: Array[AnyRef]): SQLArray =
    underlying.createArrayOf(typeName, elements)

  override def setSavepoint(): Savepoint =
    underlying.setSavepoint()

  override def setSavepoint(name: String): Savepoint =
    underlying.setSavepoint(name)

  override def close(): Unit =
    underlying.close()

  override def createNClob(): NClob =
    underlying.createNClob()

  override def rollback(): Unit =
    underlying.rollback()

  override def rollback(savepoint: Savepoint): Unit =
    underlying.rollback(savepoint)

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit =
    underlying.setNetworkTimeout(executor, milliseconds)

  override def setTypeMap(map: JMap[String, Class[_]]): Unit =
    underlying.setTypeMap(map)

  override def isValid(timeout: Int): Boolean =
    underlying.isValid(timeout)

  override def getAutoCommit: Boolean =
    underlying.getAutoCommit

  override def clearWarnings(): Unit =
    underlying.clearWarnings()

  override def getSchema: String =
    underlying.getSchema

  override def getNetworkTimeout: Int =
    underlying.getNetworkTimeout

  override def isClosed: Boolean =
    underlying.isClosed

  override def getTransactionIsolation: Int =
    underlying.getTransactionIsolation

  override def createStruct(typeName: String, attributes: Array[AnyRef]): Struct =
    underlying.createStruct(typeName, attributes)

  override def getClientInfo(name: String): String =
    underlying.getClientInfo(name)

  override def getClientInfo: Properties =
    underlying.getClientInfo

  override def getTypeMap: JMap[String, Class[_]] =
    underlying.getTypeMap

  override def unwrap[T](iface: Class[T]): T =
    underlying.unwrap(iface)

  override def isWrapperFor(iface: Class[_]): Boolean =
    underlying.isWrapperFor(iface)
}
